"""Sudoku dataset interfaces and loading utilities.

This module supports loading Sudoku data generated by the HRM repository
(`dataset/build_sudoku_dataset.py`).
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import List

import numpy as np


@dataclass
class SudokuExample:
    puzzle: List[List[int]]
    solution: List[List[int]]
    difficulty: str


class SudokuDataset:
    """Dataset abstraction for Sudoku experiments.

    Expected on-disk format matches HRM's generated dataset layout:

    .. code-block:: text

        <dataset_path>/
          train/
            dataset.json
            all__inputs.npy
            all__labels.npy
          test/
            dataset.json
            all__inputs.npy
            all__labels.npy

    HRM stores Sudoku tokens as values in ``[1, 10]`` where ``1`` encodes blank
    and ``10`` encodes digit ``9``. This loader decodes values back to ``[0, 9]``.
    """

    VALID_SPLITS = {"train", "test", "val"}
    VALID_DIFFICULTIES = {"easy", "medium", "hard"}

    def __init__(self, split: str = "train", dataset_path: str | Path = "data/sudoku-extreme-full") -> None:
        if split not in self.VALID_SPLITS:
            raise ValueError(f"Unsupported split '{split}'. Expected one of {sorted(self.VALID_SPLITS)}.")

        self.split = split
        self.dataset_path = Path(dataset_path)
        self.examples = self._load_hrm_examples()

    def _load_hrm_examples(self) -> List[SudokuExample]:
        # Map optional val split to test if only HRM train/test are present.
        split_dir = self.dataset_path / self.split
        if not split_dir.exists() and self.split == "val":
            split_dir = self.dataset_path / "test"

        metadata_path = split_dir / "dataset.json"
        inputs_path = split_dir / "all__inputs.npy"
        labels_path = split_dir / "all__labels.npy"

        for required in (metadata_path, inputs_path, labels_path):
            if not required.exists():
                raise FileNotFoundError(
                    f"Missing HRM dataset file: {required}. "
                    "Generate data with HRM's dataset/build_sudoku_dataset.py first."
                )

        # Load metadata to validate set naming.
        with metadata_path.open("r", encoding="utf-8") as f:
            metadata = json.load(f)
        if "sets" not in metadata or "all" not in metadata["sets"]:
            raise ValueError(f"Unexpected HRM metadata format in {metadata_path}.")

        raw_inputs = np.load(inputs_path)
        raw_labels = np.load(labels_path)

        if raw_inputs.shape != raw_labels.shape:
            raise ValueError("Inputs and labels have mismatched shapes.")
        if raw_inputs.ndim != 2 or raw_inputs.shape[1] != 81:
            raise ValueError("Expected HRM Sudoku arrays with shape (N, 81).")

        inputs = (raw_inputs.astype(np.int32) - 1).reshape(-1, 9, 9)
        labels = (raw_labels.astype(np.int32) - 1).reshape(-1, 9, 9)

        examples: List[SudokuExample] = []
        for puzzle, solution in zip(inputs, labels):
            self._validate_grid(puzzle, allow_blank=True)
            self._validate_grid(solution, allow_blank=False)
            difficulty = self._infer_difficulty(puzzle)
            examples.append(
                SudokuExample(
                    puzzle=puzzle.tolist(),
                    solution=solution.tolist(),
                    difficulty=difficulty,
                )
            )
        return examples

    @staticmethod
    def _validate_grid(grid: np.ndarray, allow_blank: bool) -> None:
        if grid.shape != (9, 9):
            raise ValueError(f"Expected 9x9 Sudoku grid, got {grid.shape}.")
        min_val = 0 if allow_blank else 1
        if not np.all((grid >= min_val) & (grid <= 9)):
            raise ValueError(f"Grid values out of range [{min_val}, 9].")

    @classmethod
    def _infer_difficulty(cls, puzzle: np.ndarray) -> str:
        givens = int(np.count_nonzero(puzzle))
        if givens >= 36:
            difficulty = "easy"
        elif givens >= 30:
            difficulty = "medium"
        else:
            difficulty = "hard"
        if difficulty not in cls.VALID_DIFFICULTIES:
            raise ValueError(f"Invalid inferred difficulty '{difficulty}'.")
        return difficulty

    def __len__(self) -> int:
        return len(self.examples)

    def __getitem__(self, idx: int) -> SudokuExample:
        return self.examples[idx]
